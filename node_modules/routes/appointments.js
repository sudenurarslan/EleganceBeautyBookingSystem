const express = require('express');
const { body, validationResult } = require('express-validator');
const moment = require('moment');
const db = require('../config/database');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();

// Randevu oluştur
router.post('/', authenticateToken, [
  body('service_id').isInt().withMessage('Geçerli bir hizmet seçin'),
  body('specialist_id').isInt().withMessage('Geçerli bir uzman seçin'),
  body('appointment_date').isDate().withMessage('Geçerli bir tarih seçin'),
  body('appointment_time').matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/).withMessage('Geçerli bir saat seçin')
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { service_id, specialist_id, appointment_date, appointment_time } = req.body;
    const user_id = req.user.id;
    
    // Hizmet bilgilerini al
    const [services] = await db.execute(
      'SELECT * FROM services WHERE id = ? AND is_active = TRUE',
      [service_id]
    );
    
    if (services.length === 0) {
      return res.status(404).json({ error: 'Hizmet bulunamadı' });
    }
    
    const service = services[0];
    
    // Uzman kontrolü
    const [specialists] = await db.execute(
      'SELECT * FROM specialists WHERE id = ? AND status = "active"',
      [specialist_id]
    );
    
    if (specialists.length === 0) {
      return res.status(404).json({ error: 'Uzman bulunamadı veya müsait değil' });
    }
    
    // Uzmanın bu hizmeti verip veremediğini kontrol et
    const [specialistServices] = await db.execute(
      'SELECT * FROM specialist_services WHERE specialist_id = ? AND service_id = ?',
      [specialist_id, service_id]
    );
    
    if (specialistServices.length === 0) {
      return res.status(400).json({ error: 'Seçilen uzman bu hizmeti vermiyor' });
    }
    
    // Randevu çakışması kontrolü
    const appointmentDateTime = moment(`${appointment_date} ${appointment_time}`);
    const endTime = appointmentDateTime.clone().add(service.duration_minutes, 'minutes');
    
    const [conflicts] = await db.execute(`
      SELECT * FROM appointments 
      WHERE specialist_id = ? 
      AND appointment_date = ? 
      AND status IN ('upcoming', 'confirmed')
      AND (
        (appointment_time <= ? AND DATE_ADD(CONCAT(appointment_date, ' ', appointment_time), INTERVAL duration_minutes MINUTE) > ?)
        OR
        (appointment_time < ? AND appointment_time >= ?)
      )
    `, [specialist_id, appointment_date, appointment_time, appointment_time, endTime.format('HH:mm:ss'), appointment_time]);
    
    if (conflicts.length > 0) {
      return res.status(400).json({ error: 'Bu tarih ve saatte uzman müsait değil' });
    }
    
    // Randevu numarası oluştur
    const appointment_number = 'RND-' + Date.now().toString().slice(-6);
    
    // Randevu oluştur
    const [result] = await db.execute(`
      INSERT INTO appointments 
      (appointment_number, user_id, service_id, specialist_id, appointment_date, appointment_time, duration_minutes, price, status) 
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'upcoming')
    `, [appointment_number, user_id, service_id, specialist_id, appointment_date, appointment_time, service.duration_minutes, service.price]);
    
    res.status(201).json({
      message: 'Randevu başarıyla oluşturuldu',
      appointment: {
        id: result.insertId,
        appointment_number,
        service_name: service.name,
        appointment_date,
        appointment_time,
        duration_minutes: service.duration_minutes,
        price: service.price
      }
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Randevu oluşturulurken bir hata oluştu' });
  }
});

// Kullanıcının randevularını getir
router.get('/my-appointments', authenticateToken, async (req, res) => {
  try {
    const user_id = req.user.id;
    const { status } = req.query;
    
    let query = `
      SELECT 
        a.*,
        s.name as service_name,
        s.icon as service_icon,
        sp.name as specialist_name,
        sp.title as specialist_title
      FROM appointments a
      JOIN services s ON a.service_id = s.id
      JOIN specialists sp ON a.specialist_id = sp.id
      WHERE a.user_id = ?
    `;
    
    const params = [user_id];
    
    if (status) {
      query += ' AND a.status = ?';
      params.push(status);
    }
    
    query += ' ORDER BY a.appointment_date DESC, a.appointment_time DESC';
    
    const [appointments] = await db.execute(query, params);
    
    res.json(appointments);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Randevular alınırken bir hata oluştu' });
  }
});

// Randevu iptal et
router.put('/:id/cancel', authenticateToken, async (req, res) => {
  try {
    const appointment_id = req.params.id;
    const user_id = req.user.id;
    const { reason } = req.body;
    
    // Randevu kontrolü
    const [appointments] = await db.execute(
      'SELECT * FROM appointments WHERE id = ? AND user_id = ?',
      [appointment_id, user_id]
    );
    
    if (appointments.length === 0) {
      return res.status(404).json({ error: 'Randevu bulunamadı' });
    }
    
    const appointment = appointments[0];
    
    if (appointment.status !== 'upcoming') {
      return res.status(400).json({ error: 'Bu randevu iptal edilemez' });
    }
    
    // İptal işlemi
    await db.execute(`
      UPDATE appointments 
      SET status = 'cancelled', 
          cancellation_reason = ?, 
          cancelled_at = NOW() 
      WHERE id = ?
    `, [reason || 'Müşteri tarafından iptal edildi', appointment_id]);
    
    res.json({ message: 'Randevu başarıyla iptal edildi' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Randevu iptal edilirken bir hata oluştu' });
  }
});

// Müsait randevu saatlerini getir
router.get('/available-slots', authenticateToken, async (req, res) => {
  try {
    const { specialist_id, date, service_id } = req.query;
    
    if (!specialist_id || !date || !service_id) {
      return res.status(400).json({ error: 'Uzman, tarih ve hizmet bilgisi gerekli' });
    }
    
    // Hizmet süresini al
    const [services] = await db.execute(
      'SELECT duration_minutes FROM services WHERE id = ?',
      [service_id]
    );
    
    if (services.length === 0) {
      return res.status(404).json({ error: 'Hizmet bulunamadı' });
    }
    
    const duration = services[0].duration_minutes;
    
    // Uzmanın çalışma saatlerini al
    const dayOfWeek = moment(date).isoWeekday();
    const [schedules] = await db.execute(
      'SELECT * FROM specialist_schedules WHERE specialist_id = ? AND day_of_week = ? AND is_active = TRUE',
      [specialist_id, dayOfWeek]
    );
    
    if (schedules.length === 0) {
      return res.json({ available_slots: [] });
    }
    
    const schedule = schedules[0];
    
    // Uzmanın o günkü randevularını al
    const [appointments] = await db.execute(
      'SELECT appointment_time, duration_minutes FROM appointments WHERE specialist_id = ? AND appointment_date = ? AND status IN ("upcoming", "confirmed")',
      [specialist_id, date]
    );
    
    // Müsait saatleri hesapla
    const availableSlots = [];
    const startTime = moment(schedule.start_time, 'HH:mm:ss');
    const endTime = moment(schedule.end_time, 'HH:mm:ss');
    const slotDuration = 30; // 30 dakikalık slotlar
    
    let currentSlot = startTime.clone();
    
    while (currentSlot.clone().add(duration, 'minutes').isSameOrBefore(endTime)) {
      const slotTime = currentSlot.format('HH:mm:ss');
      const slotEndTime = currentSlot.clone().add(duration, 'minutes');
      
      // Öğle arası kontrolü (12:30-13:00)
      const lunchStart = moment('12:30', 'HH:mm');
      const lunchEnd = moment('13:00', 'HH:mm');
      
      if (currentSlot.isBetween(lunchStart, lunchEnd) || slotEndTime.isAfter(lunchStart) && currentSlot.isBefore(lunchEnd)) {
        currentSlot.add(slotDuration, 'minutes');
        continue;
      }
      
      // Çakışma kontrolü
      let isConflict = false;
      for (const apt of appointments) {
        const aptStart = moment(apt.appointment_time, 'HH:mm:ss');
        const aptEnd = aptStart.clone().add(apt.duration_minutes, 'minutes');
        
        if (
          (currentSlot.isSameOrAfter(aptStart) && currentSlot.isBefore(aptEnd)) ||
          (slotEndTime.isAfter(aptStart) && slotEndTime.isSameOrBefore(aptEnd)) ||
          (currentSlot.isSameOrBefore(aptStart) && slotEndTime.isSameOrAfter(aptEnd))
        ) {
          isConflict = true;
          break;
        }
      }
      
      if (!isConflict) {
        availableSlots.push(currentSlot.format('HH:mm'));
      }
      
      currentSlot.add(slotDuration, 'minutes');
    }
    
    res.json({ available_slots: availableSlots });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Müsait saatler alınırken bir hata oluştu' });
  }
});

module.exports = router;